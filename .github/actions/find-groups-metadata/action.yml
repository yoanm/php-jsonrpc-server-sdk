name: TODO
description: TODO
inputs:
  root:
    description: TODO
    required: true
outputs:
  list:
    description: Info
    value: ${{ steps.main.outputs.list }}
  matrix:
    description: Matrix
    value: ${{ steps.main.outputs.matrix }}
  reports:
    description: Reports
    value: ${{ steps.main.outputs.reports }}

runs:
  using: "composite"
  steps:
    - id: validate
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const { ROOT } = process.env;

          await core.group('Validate inputs', async () => {
            core.debug(`ROOT='${ROOT}'`);
            if (0 === ROOT.trim().length) {
              core.setFailed('You must provide a path directory !');
            }
          });

    - id: main
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const {resolve: pathResolve, dirname: pathDirname} = require('path');
          const fs = require('fs');

          const { ROOT } = process.env;

          const absWorkspace = pathResolve(ROOT);
          
          function enhanceMetadataListWithGroup(original) {
            const counterByDirectory = {};
            for (const data of original) {
              let directory = data.path;
              while (directory.length > 0 && PATH !== directory) {
                counterByDirectory[directory] = (counterByDirectory[directory] ?? 0) + 1;
                directory = pathDirname(directory);
              }
            }
            core.info(`counterByDirectory='${JSON.stringify(counterByDirectory)}'`);
            const directorySetByCounter = [];
            for (const directory of Object.keys(counterByDirectory)) {
              const counter = counterByDirectory[directory];
              if (!Array.isArray(directorySetByCounter[counter])) {
                directorySetByCounter[counter] = new Set();
              }
              directorySetByCounter[counter].add(directory);
            }
            core.info(`directorySetByCounter='${JSON.stringify(directorySetByCounter)}'`);
            if (directorySetByCounter.length > 0) {
              const mostKnownDirectories = directorySetByCounter[directorySetByCounter.length - 1].keys();
              const groupDirectories = mostKnownDirectories.filter(v => {
                // Remove directories shared by at least another one
                return undefined === mostKnownDirectories.find(v2 => v !== v2 && v === v2.substring(0, v.length));
              });
          
              core.info(`groupDirectories='${JSON.stringify(groupDirectories)}'`);
            }
          
            return original;
          }

          const metadataFileList = await core.group(`Look for metadata files under '${ROOT}'`, async () => {
            const res = [];
            const globber = await glob.create(`${absWorkspace}/**/.reports-group-metadata.json`);
            for await (const file of globber.globGenerator()) {
              core.info(`Found ${file}`);
              const filepath = file.replace(`${absWorkspace}/`, '');

              core.debug(`filepath='${filepath}'`);

              res.push(filepath);
            }
            return res;
          });
          core.debug(`metadataFileList='${JSON.stringify(metadataFileList)}'`);

          const metadataList = await core.group('Build metadata', async () => {
            const res = [];
            for (const file of metadataFileList) {
              core.debug(`file='${file}'`);

              const fullPath = pathDirname(file);

              core.info(`Process ${fullPath} directory`);

              const globber = await glob.create(`${fullPath}/report-*`);
              const reportList = JSON.parse(REPORTS).map(fp => fp.replace(`${fullPath}/`, ''));
              const metadataContent = fs.readFileSync(file);

              const item = {...JSON.parse(metadataContent), path: fullPath, reports: reportList};

              core.debug(`item='${JSON.stringify(item)}'`);

              res.push(item);
            }

            const metadataList = enhanceMetadataListWithGroup(res);
            
            const metadataListString = JSON.stringify(metadataList);
            core.debug(`metadataList='${metadataListString}'`);
            
            core.setOutput("list", metadataListString)
          
            return metadataList;
          });

          await core.group('Build matrix', async () => {
            const matrixInclude = [];
            for (const metadata of metadataList) {
              const item = {
                ...metadata,
                reports: JSON.stringify(metadata.reports),
                flags: JSON.stringify(metadata.flags),
              };

              core.debug(`item='${JSON.stringify(item)}'`);

              matrixInclude.push(item);
            }

            const matrix = {include: matrixInclude};
  
            const matrixString = JSON.stringify(matrix);
            core.debug(`matrix='${matrixString}'`);
  
            core.setOutput("matrix", matrixString);
          });

          await core.group('Build full report list', async () => {
            const reportList = [];
            for (const metadata of metadataList) {
              const item = metadata.reports.map(fp => `${metadata.path}/${fp}`);

              core.debug(`item='${JSON.stringify(item)}'`);

              reportList.push(item);
            }

            const reportListString = JSON.stringify(reportList);
            core.debug(`reportList='${reportListString}'`);
  
            core.setOutput("reports", reportListString);
          });
