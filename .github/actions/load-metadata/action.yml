name: TODO
description: TODO

inputs:
  from:
    description: A group directory or a glob pattern in order to find group directories and merge their metadata
    required: true
  format:
    description: string (default) or json
    default: string
  glue-string:
    description: String used to concatenate values when 'string' format is used (default to comma)
    default: ','
  follow-symbolic-links:
    description: |
      Indicates whether to follow symbolic links when resolving `from`
    default: 'true'

outputs:
  # @TODO Re-add individual properties since toJson() doesn't seem available everywhere :|
  # @TODO Add following properties: found?, count
  metadata:
    description: |
      A JSON encoded group metadata object, if string format is used or in case of group directory has been provided. 
      Else an JSON encoded array of group metadata object
    value: ${{ steps.build-outputs.outputs.metadata }}

runs:
  using: "composite"
  steps:
    - name: Make action inputs available for actions/github-script scripts
      uses: actions/github-script@v7
      env:
        INPUT_MAP: ${{ toJson(inputs) }}
      with:
        script: |
          Object.entries(JSON.parse(process.env.INPUT_MAP)).forEach(([key, value]) => {
            const envName = 'INPUT_' + key.replace(/ /g, '_').toUpperCase();
            core.debug(`Promote ${key} input as ${envName} env var. value='${value}'`);
            core.exportVariable(envName, value);
          });

    - id: resolve-paths
      uses: actions/github-script@v7
      with:
        script: |
          const {dirname: pathDirname, join: pathJoin} = require('path');
          const fromList = core.getMultilineInput('from', {required: true});
          const pattern = fromList.map(item => pathJoin(item, '**', '.reports-group-metadata.json')).join('\n');
          const globber = await glob.create(pattern, {followSymbolicLinks: core.getBooleanInput('follow-symbolic-links', {required: true})});
          
          const pathList = (await globber.glob()).map((file) => {
            const groupPath = pathDirname(file);
            core.info(`Found group under '${groupPath}' directory`);
            
            return groupPath;
          });
          
          core.setOutput('paths', JSON.stringify(pathList));

    - id: build-metadata
      uses: actions/github-script@v7
      env:
        PATH_LIST: ${{ steps.resolve-paths.outputs.paths }}
      with:
        script: |
          const fs = require('fs');
          const {join: pathJoin} = require('path');
          const {PATH_LIST} = process.env;
          const pathList = [...JSON.parse(PATH_LIST).values()]; // .values() + spread to ensure array rather than object ....
          
          function loadGroupMetadata(groupPath) {
            const metadata = JSON.parse(fs.readFileSync(pathJoin(groupPath, '.reports-group-metadata.json')));
            
            return {...metadata, path: groupPath, 'report-paths': metadata.reports.map(r => pathJoin(groupPath, r))};
          }
          
          const metadataList = pathList.map(p => loadGroupMetadata(p));
          core.setOutput('metadata-list', JSON.stringify(metadataList));

    - id: build-outputs
      uses: actions/github-script@v7
      env:
        METADATA_LIST: ${{ steps.build-metadata.outputs.metadata-list }}
      with:
        script: |
          const {resolve: pathResolve} = require('path');
          const {METADATA_LIST} = process.env;
          
          const metadataList = [...JSON.parse(METADATA_LIST).values()]; // .values() + spread to ensure array rather than object ....
          core.debug('debug: ' + (typeof METADATA_LIST));
          core.debug('debug: ' + (typeof metadataList));
          
          if ('string' !== core.getInput('format')) {
            // Detect if provided `paths` was a group directory 
            const isSingleMetadata = metadataList.length === 1 && pathResolve(metadataList[0].path) === pathResolve(core.getInput('from', {required: true}));
            const result = isSingleMetadata ? metadataList.shift() : metadataList;
            core.setOutput('metadata', JSON.stringify(result));
          } else {
            const glueString = core.getInput('glue-string', {required: true, trimWhitespace: false});
            const formatScalar = (key) => [...(new Set(metadataList.map(m => m[key]))).values()].join(glueString);
            const formatList = (key) => [...(new Set(metadataList.map(m => m[key]).flat())).values()].join(glueString);
            const result = {
              name: formatScalar('name'),
              format: formatScalar('format'),
              reports: formatList('reports'),
              flags: formatList('flags'),
              path: formatScalar('path'),
              'report-paths': formatList('report-paths')
            };
            core.setOutput('metadata', JSON.stringify(result));
          }
