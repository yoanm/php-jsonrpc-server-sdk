name: TODO
description: TODO
inputs:
  root:
    description: TODO
    required: true
outputs:
  metadata-list:
    description: Info
    value: ${{ steps.main.outputs.metadata-list }}
  matrix:
    description: Matrix
    value: ${{ steps.main.outputs.matrix }}
  reports:
    description: Reports
    value: ${{ steps.main.outputs.reports }}

runs:
  using: "composite"
  steps:
    - id: validate
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const { ROOT } = process.env;

          await core.group('Validate inputs', async () => {
            core.debug(`ROOT='${ROOT}'`);
            if (0 === ROOT.trim().length) {
              core.setFailed('You must provide a path directory !');
            }
          });

    - id: main
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const {resolve: pathResolve, dirname: pathDirname} = require('path');
          const fs = require('fs');

          const { ROOT } = process.env;

          const absWorkspace = pathResolve(ROOT);
          
          function enhanceMetadataListWithGroup(original) {
            const counterByDirectory = {};
            for (const data of original) {
              let directory = data.path;
              while (directory.length > 0 && PATH !== directory) {
                counterByDirectory[directory] = (counterByDirectory[directory] ?? 0) + 1;
                directory = pathDirname(directory);
              }
            }
            core.info(`counterByDirectory='${JSON.stringify(counterByDirectory)}'`);
            const directorySetByCounter = [];
            for (const directory of Object.keys(counterByDirectory)) {
              const counter = counterByDirectory[directory];
              if (!Array.isArray(directorySetByCounter[counter])) {
                directorySetByCounter[counter] = new Set();
              }
              directorySetByCounter[counter].add(directory);
            }
            core.info(`directorySetByCounter='${JSON.stringify(directorySetByCounter)}'`);
            if (directorySetByCounter.length > 0) {
              const mostKnownDirectories = directorySetByCounter[directorySetByCounter.length - 1].keys();
              const groupDirectories = mostKnownDirectories.filter(v => {
                // Remove directories shared by at least another one
                return undefined === mostKnownDirectories.find(v2 => v !== v2 && v === v2.substring(0, v.length));
              });
          
              core.info(`groupDirectories='${JSON.stringify(groupDirectories)}'`);
            }
          
            return original;
          }

          const metadataFileList = await core.group('Find metadata files', async () => {
            const res = [];
            const globber = await glob.create(`${absWorkspace}/**/.coverage-reports-metadata.json`);
            for await (const file of globber.globGenerator()) {
              core.info(`Found ${file}`);
              const filepath = file.replace(`${absWorkspace}/`, '');

              core.debug(`filepath='${filepath}'`);

              res.push(filepath);
            }
            return res;
          });
          core.debug(`metadataFileList='${JSON.stringify(metadataFileList)}'`);

          const metadataList = await core.group('Build metadata', async () => {
            const res = [];
            for (const file of metadataFileList) {
              core.debug(`file='${file}'`);

              const fullPath = pathDirname(file);

              core.info(`Process ${fullPath} directory`);

              const globber = await glob.create(`${fullPath}/report-*`);
              const reportList = JSON.parse(REPORTS).map(fp => fp.replace(`${fullPath}/`, ''));
              const metadataContent = fs.readFileSync(file);

              const item = {...JSON.parse(metadataContent), path: fullPath, reports: reportList};

              core.debug(`item='${JSON.stringify(item)}'`);

              res.push(item);
            }

            return enhanceMetadataListWithGroup(res);
          });
          const metadataListString = JSON.stringify(metadataList);
          core.debug(`metadataList='${metadataListString}'`);

          core.setOutput("metadata-list", metadataListString);

          const matrixInclude = await core.group('Build matrix', async () => {
            const res = [];
            for (const metadata of metadataList) {
              const item = {
                format: metadata.format,
                name: metadata.name,
                path: metadata.path,
                reports: JSON.stringify(metadata.reports),
                flags: JSON.stringify(metadata.flags),
              };

              core.debug(`item='${JSON.stringify(item)}'`);

              res.push(item);
            }

            return res;
          });
          const matrix = {include: matrixInclude};

          const matrixString = JSON.stringify(matrix);
          core.debug(`matrix='${matrixString}'`);

          core.setOutput("matrix", matrixString);

          const reportList = await core.group('Build full report list', async () => {
            const res = [];
            for (const metadata of metadataList) {
              const item = metadata.reports.map(fp => `${metadata.path}/${fp}`);

              core.debug(`item='${JSON.stringify(item)}'`);

              res.push(item);
            }

            return res;
          });
          const reportListString = JSON.stringify(reportList);
          core.debug(`reportList='${reportListString}'`);

          core.setOutput("reports", reportListString);
