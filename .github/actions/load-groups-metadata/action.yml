name: TODO
description: TODO
inputs:
  root:
    description: TODO
    required: true
outputs:
  map:
    description: TODO
    value: ${{ steps.main.outputs.map }}
  matrix:
    description: TODO
    value: ${{ steps.main.outputs.matrix }}
  reports:
    description: TODO
    value: ${{ steps.main.outputs.reports }}

# TODO Move entire code to TS

runs:
  using: "composite"
  steps:
    - id: validate
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const { ROOT } = process.env;

          await core.group('Validate inputs', async () => {
            core.debug(`ROOT='${ROOT}'`);
            if (0 === ROOT.trim().length) {
              core.setFailed('You must provide a path directory !');
            }

            core.info('All good !!');
          });

    - id: main
      uses: actions/github-script@v7
      env:
        ROOT: ${{ inputs.root }}
      with:
        script: |
          const {resolve: pathResolve, dirname: pathDirname} = require('path');
          const fs = require('fs');

          const { ROOT } = process.env;

          const absWorkspace = pathResolve(ROOT);
          
          function enhanceMetadataMapWithGroup(original) {
            const counterByDirectory = {};
            for (const groupPath of original) {
              let directory = data.path;
              while (directory.length > 0 && ROOT !== directory) {
                counterByDirectory[directory] = (counterByDirectory[directory] ?? 0) + 1;
                directory = pathDirname(directory);
              }
            }
            core.info(`counterByDirectory='${JSON.stringify(counterByDirectory)}'`);
            const directorySetByCounter = [];
            for (const directory of Object.keys(counterByDirectory)) {
              const counter = counterByDirectory[directory];
              if (!Array.isArray(directorySetByCounter[counter])) {
                directorySetByCounter[counter] = new Set();
              }
              directorySetByCounter[counter].add(directory);
            }
            core.info(`directorySetByCounter='${JSON.stringify(directorySetByCounter)}'`);
            if (directorySetByCounter.length > 0) {
              const mostKnownDirectories = directorySetByCounter[directorySetByCounter.length - 1].keys();
              const groupDirectories = mostKnownDirectories.filter(v => {
                // Remove directories shared by at least another one
                return undefined === mostKnownDirectories.find(v2 => v !== v2 && v === v2.substring(0, v.length));
              });
          
              core.debug(`groupDirectories='${JSON.stringify(groupDirectories)}'`);
            }
          
            return original;
          }

          const metadataFileList = await core.group(`Look for metadata files under '${ROOT}'`, async () => {
            const res = [];
            const globber = await glob.create(`${absWorkspace}/**/.reports-group-metadata.json`);
            for await (const file of globber.globGenerator()) {
              const filepath = file.replace(`${absWorkspace}/`, '');
              core.info(`Found '${filepath}'`);

              res.push(filepath);
            }
            return res;
          });
          core.debug(`metadataFileList='${JSON.stringify(metadataFileList)}'`);

          const metadataMap = await core.group('Build metadata', async () => {
            const res = {};
            for (const file of metadataFileList) {
              core.debug(`file='${file}'`);

              const groupPath = pathDirname(file);

              core.info(`Process ${groupPath} directory`);

              const globber = await glob.create(`${groupPath}/*-report-[0-99]`);
              const metadataContent = fs.readFileSync(`${ROOT}/${file}`);
              const metadata = JSON.parse(metadataContent);

              const item = {...metadata, path: groupPath};

              core.debug(`item='${JSON.stringify(item)}'`);

              res[groupPath] = item;
            }

            const map = res;
            
            const mapString = JSON.stringify(map);
            core.debug(`map='${mapString}'`);
            
            core.setOutput("map", mapString)
          
            return map;
          });

          await core.group('Build matrix', async () => {
            const matrixInclude = [];
            for (const groupPath of Object.keys(metadataMap)) {
              const metadata = metadataMap[groupPath];
              const item = {
                ...metadata,
                path: groupPath,
                reports: JSON.stringify(metadata.reports),
                flags: JSON.stringify(metadata.flags),
              };

              core.debug(`item='${JSON.stringify(item)}'`);

              matrixInclude.push(item);
            }

            const matrix = {include: matrixInclude};
  
            const matrixString = JSON.stringify(matrix);
            core.debug(`matrix='${matrixString}'`);
  
            core.setOutput("matrix", matrixString);
          });

          await core.group('Build full report list', async () => {
            const reportList = [];
            for (const groupPath of Object.keys(metadataMap)) {
              metadataMap[groupPath]
                .reports
                .map(fp => `${groupPath}/${fp}`)
                .forEach(fp => {
                  core.info(`Add '${fp}'`);
                  reportList.push(fp);
                });
            }

            const reportListString = JSON.stringify(reportList);
            core.debug(`reportList='${reportListString}'`);
  
            core.setOutput("reports", reportListString);
          });
