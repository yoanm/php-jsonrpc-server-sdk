name: Create a coverage report group
description: |
  Create a directory under provided path holding a copy all reports to upload and a metada file.
  Reports are expected to share the same format !
inputs:
  name:
    description: Group name
    required: true
  format:
    description: "`clover`, `cobertura`, `lcov`, etc"
    required: true
  files:
    description: Multiline list of reports attached to the group
    required: true
  flags:
    description: Multiline list of flags attached to the group
    required: false
  path:
    description: Root directory for the group directory (default to current directory)
    required: false
  follow-symbolic-links:
    description: |
      Indicates whether to follow symbolic links when resolving `files`
    default: 'true'

outputs:
  path:
    description: Path to the group directory
    value: ${{ steps.build-outputs.outputs.path }}
  reports:
    description: Multiline List of created reports for the group
    value: ${{ steps.build-outputs.outputs.reports }}
  files:
    description: Multiline list of reports attached to the group. 
      Will be different than provided `files` if `glob-reports` is `true` !
    value: ${{ steps.build-outputs.outputs.files }}

runs:
  using: "composite"
  steps:
    - name: Make action inputs available for actions/github-script scripts
      uses: actions/github-script@v7
      env:
        INPUT_MAP: ${{ toJson(inputs) }}
      with:
        script: |
          Object.entries(JSON.parse(process.env.INPUT_MAP)).forEach(([key, value]) => {
            const envName = 'INPUT_' + key.replace(/ /g, '_').toUpperCase();
            core.debug(`Promote ${key} input as ${envName} env var. value='${value}'`);
            core.exportVariable(envName, value);
          });

    - uses: actions/github-script@v7
      with:
        script: |
          core.info('Validate required inputs')
          core.getInput('name', {required: true});
          core.getInput('format', {required: true});
          core.getInput('files', {required: true});

          // Following are not really required, but are expected to have a default value at least, so a valid value is actually expected
          core.getBooleanInput('follow-symbolic-links', {required: true});

    - id: resolve-directory
      uses: actions/github-script@v7
      with:
        script: |
          core.info('Resolve path');
          const {resolve: pathResolve} = require('path');
          
          const result = pathResolve(core.getInput('path'), core.getInput('name', {required: true}));
          core.debug('result=' + result);
          core.setOutput('directory', result);

    - id: resolve-files
      uses: actions/github-script@v7
      with:
        script: |
          core.info('Resolve files');
          const {resolve: pathResolve} = require('path');
          const {GITHUB_WORKSPACE} = process.env;
          
          function pathFromGHWorkspace(...segments) {
            const p = pathResolve(...segments);
            return p.startsWith(GITHUB_WORKSPACE) ? p.replace(GITHUB_WORKSPACE, '').substring(1) : p;
          }
          
          const globber = await glob.create(
            core.getInput('files', {required: true}),
            {followSymbolicLinks: core.getBooleanInput('follow-symbolic-links', {required: true})}
          );
          const result = (await globber.glob()).map(fp => pathFromGHWorkspace(fp));
          if (0 === result.length) {
            core.setFailed('You must provide at least one report !');
          }
          result.forEach(fp => core.info(`Found ${fp}`));
          const resultString = JSON.stringify(result);
          core.debug('result=' + resultString);
          core.setOutput('list', resultString);

    - id: build-reports-map
      uses: actions/github-script@v7
      env:
        RESOLVED_FILES: ${{ steps.resolve-files.outputs.list }}
        DIRECTORY: ${{ steps.resolve-directory.outputs.directory }}
      with:
        script: |
          return core.group('Build file map', async () => {
            const {basename: pathBasename, resolve: pathResolve} = require('path');
            const {GITHUB_WORKSPACE} = process.env;
            const {RESOLVED_FILES, DIRECTORY} = process.env;
            
            function pathFromGHWorkspace(...segments) {
              const p = pathResolve(...segments);
              return p.startsWith(GITHUB_WORKSPACE) ? p.replace(GITHUB_WORKSPACE, '').substring(1) : p;
            }
            
            let counter = 0;
            const files = [...JSON.parse(RESOLVED_FILES).values()]; // .values() + spread to ensure array rather than object ....
            const result = files.map(filepath => {
              core.info('Found ' + filepath);
              // Ensure report files uniqueness while keeping a bit of clarity regarding the mapping with original files !
              const filename = pathBasename(filepath) + '-report-' + (++counter);
              return {source: filepath, filename: filename, dest: pathFromGHWorkspace(DIRECTORY, filename)};
            });
            const resultString = JSON.stringify(result);
            core.debug('result=' + resultString);
            core.setOutput('map', resultString);
          });

    - id: build-metadata
      uses: actions/github-script@v7
      env:
        REPORTS_MAP: ${{ steps.build-reports-map.outputs.map }}
      with:
        script: |
          const {REPORTS_MAP} = process.env;
          
          return core.group('Build group metadata', () => {
            const reportList = [...JSON.parse(REPORTS_MAP).values()]; // .values() + spread to ensure array rather than object ....
            const result = {
              name: core.getInput('name', {required: true}),
              format: core.getInput('format', {required: true}),
              reports: reportList.map(v => v.filename),
              flags: core.getMultilineInput('flags')
            };
            const resultString = JSON.stringify(result);
            core.debug('result=' + resultString);
            core.setOutput('metadata', resultString);
          });

    - uses: actions/github-script@v7
      env:
        DIRECTORY: ${{ steps.resolve-directory.outputs.directory }}
      with:
        script: |
          const {DIRECTORY} = process.env;
          
          return core.group(`Create ${DIRECTORY} group directory`, () => {
            io.mkdirP(DIRECTORY);
          });

    - uses: actions/github-script@v7
      env:
        REPORTS_MAP: ${{ steps.build-reports-map.outputs.map }}
      with:
        script: |
          const {REPORTS_MAP} = process.env;
          
          return core.group('Copy reports', async () => {
            const list = [...JSON.parse(REPORTS_MAP).values()]; // .values() + spread to ensure array rather than object ....
            return list.map(async (item) => {
              core.info(`${item.source} => ${item.dest}`);
              return io.cp(item.source, item.dest);
            });
          });

    - uses: actions/github-script@v7
      env:
        DIRECTORY: ${{ steps.resolve-directory.outputs.directory }}
        CONTENT: ${{ steps.build-metadata.outputs.metadata }}
      with:
        script: |
          const {join: pathJoin} = require('path');
          const {writeFileSync} = require('fs');
          const {DIRECTORY, CONTENT} = process.env;
          
          return core.group('Create metadata file', () => {
            const filepath = pathJoin(DIRECTORY, '.reports-group-metadata.json');
            writeFileSync(filepath, CONTENT);
          });

    - uses: actions/github-script@v7
      id: build-outputs
      env:
        DIRECTORY: ${{ steps.resolve-directory.outputs.directory }}
        FILES: ${{ steps.resolve-files.outputs.list }}
        METADATA: ${{ steps.build-metadata.outputs.metadata }}
      with:
        script: |
          const {DIRECTORY, FILES, METADATA} = process.env
          const files = [...JSON.parse(FILES).values()]; // .values() + spread to ensure array rather than object ....
          
          return core.group('Build outputs', () => {
            core.setOutput('path', DIRECTORY);
            core.setOutput('reports', JSON.parse(METADATA).reports.join('\n'));
            core.setOutput('files', files.join('\n'));
          });
